{
  "cpp": "// C++ program for Merge Sort\n#include <iostream>\nusing namespace std;\n\n// Merges two subarrays of array[].\n// First subarray is arr[begin..mid]\n// Second subarray is arr[mid+1..end]\nvoid merge(int array[], int const left, int const mid, int const right)\n{\n\tauto const subArrayOne = mid - left + 1;\n\tauto const subArrayTwo = right - mid;\n\n\t// Create temp arrays\n\tauto *leftArray = new int[subArrayOne],\n\t\t*rightArray = new int[subArrayTwo];\n\n\t// Copy data to temp arrays leftArray[] and rightArray[]\n\tfor (auto i = 0; i < subArrayOne; i++)\n\t\tleftArray[i] = array[left + i];\n\tfor (auto j = 0; j < subArrayTwo; j++)\n\t\trightArray[j] = array[mid + 1 + j];\n\n\tauto indexOfSubArrayOne = 0, // Initial index of first sub-array\n\t\tindexOfSubArrayTwo = 0; // Initial index of second sub-array\n\tint indexOfMergedArray = left; // Initial index of merged array\n\n\t// Merge the temp arrays back into array[left..right]\n\twhile (indexOfSubArrayOne < subArrayOne && indexOfSubArrayTwo < subArrayTwo) {\n\t\tif (leftArray[indexOfSubArrayOne] <= rightArray[indexOfSubArrayTwo]) {\n\t\t\tarray[indexOfMergedArray] = leftArray[indexOfSubArrayOne];\n\t\t\tindexOfSubArrayOne++;\n\t\t}\n\t\telse {\n\t\t\tarray[indexOfMergedArray] = rightArray[indexOfSubArrayTwo];\n\t\t\tindexOfSubArrayTwo++;\n\t\t}\n\t\tindexOfMergedArray++;\n\t}\n\t// Copy the remaining elements of\n\t// left[], if there are any\n\twhile (indexOfSubArrayOne < subArrayOne) {\n\t\tarray[indexOfMergedArray] = leftArray[indexOfSubArrayOne];\n\t\tindexOfSubArrayOne++;\n\t\tindexOfMergedArray++;\n\t}\n\t// Copy the remaining elements of\n\t// right[], if there are any\n\twhile (indexOfSubArrayTwo < subArrayTwo) {\n\t\tarray[indexOfMergedArray] = rightArray[indexOfSubArrayTwo];\n\t\tindexOfSubArrayTwo++;\n\t\tindexOfMergedArray++;\n\t}\n}\n\n// begin is for left index and end is\n// right index of the sub-array\n// of arr to be sorted */\nvoid mergeSort(int array[], int const begin, int const end)\n{\n\tif (begin >= end)\n\t\treturn; // Returns recursively\n\n\tauto mid = begin + (end - begin) / 2;\n\tmergeSort(array, begin, mid);\n\tmergeSort(array, mid + 1, end);\n\tmerge(array, begin, mid, end);\n}\n\n// UTILITY FUNCTIONS\n// Function to print an array\nvoid printArray(int A[], int size)\n{\n\tfor (auto i = 0; i < size; i++)\n\t\tcout << A[i] << \" \";\n}\n\n// Driver code\nint main()\n{\n\tint arr[] = { 12, 11, 13, 5, 6, 7 };\n\tauto arr_size = sizeof(arr) / sizeof(arr[0]);\n\n\tcout << \"Given array is \\n\";\n\tprintArray(arr, arr_size);\n\n\tmergeSort(arr, 0, arr_size - 1);\n\n\tcout << \"\\nSorted array is \\n\";\n\tprintArray(arr, arr_size);\n\treturn 0;\n}\n\n// This code is contributed by Mayank Tyagi\n// This code was revised by Joshua Estes\n\n",
  "Pseudo": "MergeSort(arr[], l,  r)\nIf r > l\n     1. Find the middle point to divide the array into two halves:  \n             middle m = l+ (r-l)/2\n     2. Call mergeSort for first half:   \n             Call mergeSort(arr, l, m)\n     3. Call mergeSort for second half:\n             Call mergeSort(arr, m+1, r)\n     4. Merge the two halves sorted in step 2 and 3:\n             Call merge(arr, l, m, r)"
}
